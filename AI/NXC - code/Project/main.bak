// Name: main.nxc       Date: 19-11-17
// Written by: Daniel Haraldson
//
// Description: This code is ment to controll the socoban solving
// robot based on a predefined list of commands called the plan.




// includes
#include "defines.nxc"
#include "functions.nxc"



     


// ************************************ Tasks *******************************

task MoveLightSensor(){
    // Set up variables
    float P=0 , I=0, D=0, dif=0,difOld=0;
    int Target = MAXSENSORANGLE/2;
    int dir = 1;

    // Run pdi controller
    while (true){
         // update pdi controller values
         difOld = dif;
         float dif = Target-MotorRotationCount(MOTORSENSOR);

         //  update pdi constants
         P = PC*dif;
         D = DC*(dif-difOld);
         I +=IC*dif;

         // Output to motor
         int output =  P+D+I;
         if(output > 100){output = 100;}      // Prevent clamping
         if (output <-100){output = -100;}    // Prevent clamping

         OnFwd(MOTORSENSOR, output);

         // for swinging back and forward
         if (dif*dir < PDI_THRESHHOLD){
            dir *=-1;
            Target = CenterP + Span*dir/2;
         }

         // wait some time
         Wait(20);

    }
}

task DisplayLightSensor(){
     // read the data from memory and plot it on screen
     int iSensor = 0;
     int iPosition =0;
     float yRatio = ((DISPLAY_HEIGHT)/100);
     float xRatio = ((DISPLAY_WIDTH)/Span);
     int xPos = 0;



     while (true){
            // normalize the sensor value and position
            //to the screen height and with
            xRatio = DISPLAY_WIDTH/Span;
            ResetScreen();
            Wait(10);
            
            for (int i = 0; i<(MEMORYDEBTH); i++){
                iSensor = yRatio*sensorBack[i];
                
                iPosition = xRatio*(motorSensor[i]+Span/2);


                // display the signal
                PointOut(iPosition, iSensor);
            }
            Wait(1000);

     }
}



task ExecutePath(){
     // Execute commands
     int pl = PLANLENGTH;
     for (int i=0; i<pl; i++){
         // perform switch case
         switch(PLAN[i]){
             case(MVFW):   // Move forward one block
                 Wait(1000);
                 break;

             case(MVBX):   // Move the boxe one block
                 break;

             case(MVRR):   // Move the boxe one block
                 break;

             case(MVRL):   // Move the boxe one block
                 break;
         }

     }

     // End program play silly sound
     CenterP = 0; Span = 0;
     Wait(500);
     StopTask(MoveLightSensor);
     OnFwd(MOTORSENSOR, 0);         // stop the motor sensor

     PlayFile("NO_ONE_HAS_EVER.rso");
     Wait(7000);
     StopAllTasks(); // stop the program
}

task LightSensors(){
     // take the mesured data and put it in the aray
     int iSBack,iSLeft, iSRight;

     
     while (true){
           iSBack = 0; iSLeft = 0; iSRight = 0;
           
           // read value five times and place average in memory
           for (int i = 0; i<READITERATIONS; i++){
               // add value
               iSBack += Sensor(LIGHTBACK);
               iSLeft += Sensor(LIGHTLEFT);
               iSRight += Sensor(LIGHTRIGHT);
           }
           
           // add to memory
           sensorBack[frontPointer] = iSBack/(READITERATIONS);
           sensorRight[frontPointer] = iSRight/(READITERATIONS);
           sensorLeft[frontPointer] = iSLeft/(READITERATIONS);
           motorSensor[frontPointer] = MotorRotationCount(MOTORSENSOR);

           frontPointer =(frontPointer + 1)%MEMORYDEBTH;

           Wait(1);

     }
}

task main()
{
     // inisiate all the sensorts
     init();

     // setup program tasks/behaviors
     Precedes(MoveLightSensor);
     Precedes(DisplayLightSensor);
     Precedes(LightSensors);
     Precedes(ExecutePath);




     
}
